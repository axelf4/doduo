# dumle

Tentative, currently only on paper, design of a virtual DOM library written in
Rust inspired by [React](https://reactjs.org/), [Imba.js](http://imba.io/) and
[Dodrio](https://github.com/fitzgen/dodrio).
The main distinguishing ideas are that we reconcile while building the virtual DOM
and that tag names are not stored in the virtual DOM tree,
since they already are intrinsically contained in the code.

We define a structure `Context`, which is provided to the functions rendering
the virtual DOM (VDOM):

```rust
struct Context {
	/// The current DOM node we are considering.
	cursor: Node,
	/// Our behaviour when traversing.
	mode: TraversalMode,
	/// Arena for dynamically-sized storage.
	arena: BumpAllocationArena,
}

enum TraversalMode { Creating, Updating, Removing }
```

The bump allocation arena in `Context` is double-buffered and swapped between
each render, similarily to how [Dodrio does
it](https://github.com/fitzgen/dodrio#bump-allocation).

The `mode` field specifies how the render function should behave.
The very first render it's going to be `Creating`,
that is we are simply going to append new DOM nodes to build the tree.
During subsequent render the mode is going to start off as `Updating`,
that means that we can expect and rely on the DOM nodes being were they should be.
Even though we can simply remove a parent DOM node to remove a whole subtree,
that would not take care of notifying any potential hooks defined further down the subtree.
It is for that purpose the `Removing` `TraversalMode` exists.
To illustrate, if we have the following render function graph:

```
render_root(ctx, arg)
├── ...
├── if arg
│   └── <p>Text</p>
└── ...
```

then when reconciling, we only ever have to perform any work if (1) `mode` is `Creating`
or (2) `mode` is `Updating` and `arg` has changed since the last render.
Thus the only information we would have to store is the boolean `arg`.

Each function is "limited" to two levels of nested nodes to reduce
implementation complexity.
Deeper trees are handled by recursively extracting into new function nodes.
Each render function returns the necessary data that it needs to diff itself.
It gets embedded in the calling render function's data.
Variable number of children (e.g. generated by a loop) are handled by the
bump allocation arena in the `Context`.

## Procedural macro

The procedural macro transforms render functions
consisting of a subset of the Rust language and some HTML-like syntax,
into the code necessary for diffing.
The general idea is that we first sync the top level DOM nodes, so that,
when reconciling attributes and children the node structure is known
and we can make use of a simple cursor interface with
`Node.next_sibling()`, `NodeList.item()`, etc.

Each transformed render function returns some state structure that gets
passed to it the next render.
In that structure we can store boolean flags, hooks, custom user data,
vectors of vnode keys and states of sub-render functions.

When going through the syntax tree we can essentially collapse it into trees of
a few distinct cases corresponding to the means of modifying control flow in
Rust:

* Conditional (`if`, `if let`, ...)
* Loops (`while`, `for`, ...)
* (Switch (`match`), same principle as if:s however storing
  integers instead of a boolean. Skipping for now)

Multiple nested *Conditional*:s can be collapsed into a single *Conditional*.
The same is also true for *Loop*:s.

Nodes outside of any control flow statements are truly zero-overhead;
we only have to care about them when `mode` is `Creating`/`Removing`.
Otherwise we simply skip them with:
```
cursor = cursor.next_sibling() or cursor.first_child() or cursor.childNodes.item(i);
```
(In some cases it might be worth it to just store a pointer to the DOM node if
the hierarchy is especially deep)

For example, the following render function (lifetimes omitted)
```rust
#[render]
fn render(ctx: Context, switch: bool) {
	<img />
	if switch {
		<div>Some text</div>
	}
}
```
gets (hopefully feasibly) transformed into something like
```rust
struct State {
	switch: bool,
}
fn render(ctx: Context, state: Option<State>, switch: bool) -> State {
	if ctx.mode == TraversalMode::Creating {
		append_dom_child(ctx.cursor, 'img');
	}
	if ctx.mode == TraversalMode::Creating
		|| ctx.mode == TraversalMode::Updating && state.switch != switch {
		if switch {
			append_dom_child(ctx.cursor, 'div');
		} else {
			remove_last_dom_child(ctx.cursor);
		}
	}
	if ctx.mode == TraversalMode::Creating {
		ctx.cursor.last_child().innerText = 'Some text';
	}

	State { switch }
}
```
The first iteratations of the transformation algorithm
would not have to be very complicated, just produce the correct results.
It *should* still be very fast.

While conditionals are pretty straight-forward, loops are a little more complicated.
Like with React the user has to assign each virtual node a key
(or fallback to the node index, if we're disregarding performance),
and the keys from the last render would have to be stored.
Then we can use the [LIS crate](https://github.com/axelf4/lis) for keyed list diffing.
In order to achieve `O(n)` time complexity when diffing vnode lists with only
*trivial* differences (i.e. nothing moved and contiguous insertions xor deletions),
the old nodes and the new nodes lists have to be double-ended.
This combined with the fact that we want to have parent DOM nodes diffed
before considering children,
means that we essentially have to iterate each loop twice:
once to pick up parent node keys and tag names and
once for recursively handling attrs and children.
The result of the list diffing algorithm is the created, removed, and moved nodes.
The render functions for the children need to know their `mode`:s
and we have to index into their stored states (using their old index from diffing),
thus we have to store this somehow, for example in a bump allocated vector.

When it comes down to it we have two options for generating the code for
a loop of `<nodes>`:
1. Naively duplicate the code and replace the loop innards.
2. Place the loop body inside a generator and, for each loop iteration, store
   the generator boxed in a bump allocated `Vec`. Loop through the vector twice
each time yielding once from the generator.

Option number two should always work (I think) while option one is faster for most loops.

## Difficulties

* Naming the return type of the render functions. Each return type is different
  and generated by the proc macro. Most ideal, would be being able to refer to
them by `function_name::<type>` or something.

* With this design functions and loops would have to define *a single* top
  level node. No support for a `React.Fragment` equivalent.
